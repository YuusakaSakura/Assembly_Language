### 一个源程序从写出到执行的过程

1. 编写汇编源程序

   - 使用文件编辑器，用汇编语言编写汇编源程序

   

2. 对源程序进行编译和链接

   - 使用汇编语言程序对源程序文件中的源程序进行编译，产生目标文件，再用链接程序对目标文件进行链接，生成可在操作系统中直接运行的可执行文件

   - 可执行文件包含两个部分

     - 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
     - 相关的描述信息（比如程序有多大，要占用多少内存空间等）

     

3. 执行可执行文件中的程序

   - 系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置 CS:IP 执行第一条要执行的指令），然后由 CPU 执行程序

---

### 源程序

在汇编语言源程序中，包含着两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应机器码的指令，可以被编译为机器指令，最终被 CPU 所执行。而伪指令没有对应的机器码，不会被 CPU 所执行，它是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

```
/* 一段简单的汇编语言源程序 */
assume cs:codesg

codesg segment
	
	mov ax,0123h
	mov bx,0456h
	add ax,bx
	add ax,ax
	
	mov ax,4c00h
	int 21h
	
codesg ends

end
```

以上代码中，有伪指令和汇编指令。其中，伪指令有：

- `segment` 和 `ends` 

两个需要成对使用的伪指令，在写可被编译的汇编程序时需要用到的一对伪指令。它们俩的功能是定义一个段，`segment` 说明一个段的开始，`ends` 说明一个段的结束，且一个段需要有一个名称来标识，格式为：

```
<段名> segment
	:...
<段名> ends

/* 例如上面的程序中 */
codesg segment		; 定义第一个段，段的名称为 "codesg"，这个段从此开始
	:...
codesg ends			; 名为 "codesg" 的段到此结束
```

一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当做栈空间来使用。

一个源程序中所有将被 CPU 所处理的信息（指令、数据、栈）都会被划分到不同的段中。



- `end`

`end` 是汇编程序中表示结束的一个标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 `end` ，就会结束对源程序的编译。（在写汇编程序时，如果程序写完了，请务必加上伪指令 `end` ，否则编译器无法得知程序在何处结束）



- `assume`

`assume` 用于将 CPU 的某个寄存器和一个 `segment ... ends` 的段相关联。例如上面的程序中，因为我们用 `codesg segment ... codesg ends` 定义了一个名为 `codesg` 的代码段，所以需要在程序开头，用 `assume` 将 CS 寄存器和 `codesg` 段相关联（CS 寄存器用于代码的执行）。



- `codesg` 标号

汇编程序中，除了汇编指令和伪指令外，还有一些标号，比如 "codesg" 。一个标号代指了一个地址。比如 `codesg` 在 `segment` 的前面，作为一个段的名称，这个段名称最终被编译、连接程序处理为一个段的段地址。



- 程序返回

程序在 DOS 系统（单任务系统）下的运行方式：运行一个程序时，会将 CPU 的控制器交给程序，直到程序结束，将 CPU 控制权交还给 DOS 系统。

我们会把上述的过程称之为：程序返回。但如果程序没有被结束，则 CPU 会被程序一直占用，没办法干别的事，且会一直执行命令，然后产生错误，这并不是我们所期望的。

所以我们需要使用指令来进行程序返回，其指令为：

```
mov ax,4c00h
int 21h
```

---

### 编辑、编译、连接、执行

#### 1. 编辑

我们可以使用任意文本编辑器编辑源程序，只要最终将其存储为纯文本文件即可

#### 2. 编译

#### 3. 连接

#### 4. 执行
