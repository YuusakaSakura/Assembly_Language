### 一个源程序从写出到执行的过程

1. 编写汇编源程序

   - 使用文件编辑器，用汇编语言编写汇编源程序

   

2. 对源程序进行编译和链接

   - 使用汇编语言程序对源程序文件中的源程序进行编译，产生目标文件，再用链接程序对目标文件进行链接，生成可在操作系统中直接运行的可执行文件

   - 可执行文件包含两个部分

     - 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
     - 相关的描述信息（比如程序有多大，要占用多少内存空间等）

     

3. 执行可执行文件中的程序

   - 系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置 CS:IP 执行第一条要执行的指令），然后由 CPU 执行程序

---

### 源程序

在汇编语言源程序中，包含着两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应机器码的指令，可以被编译为机器指令，最终被 CPU 所执行。而伪指令没有对应的机器码，不会被 CPU 所执行，它是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

```assembly
/* 一段简单的汇编语言源程序 */
assume cs:codesg

codesg segment
	
	mov ax,0123h
	mov bx,0456h
	add ax,bx
	add ax,ax
	
	mov ax,4c00h
	int 21h
	
codesg ends

end
```

以上代码中，有伪指令和汇编指令。其中，伪指令有：

- `segment` 和 `ends` 

两个需要成对使用的伪指令，在写可被编译的汇编程序时需要用到的一对伪指令。它们俩的功能是定义一个段，`segment` 说明一个段的开始，`ends` 说明一个段的结束，且一个段需要有一个名称来标识，格式为：

```assembly
<段名> segment
	:...
<段名> ends

/* 例如上面的程序中 */
codesg segment		; 定义第一个段，段的名称为 "codesg"，这个段从此开始
	:...
codesg ends			; 名为 "codesg" 的段到此结束
```

一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当做栈空间来使用。

一个源程序中所有将被 CPU 所处理的信息（指令、数据、栈）都会被划分到不同的段中。



- `end`

`end` 是汇编程序中表示结束的一个标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 `end` ，就会结束对源程序的编译。（在写汇编程序时，如果程序写完了，请务必加上伪指令 `end` ，否则编译器无法得知程序在何处结束）



- `assume`

`assume` 用于将 CPU 的某个寄存器和一个 `segment ... ends` 的段相关联。例如上面的程序中，因为我们用 `codesg segment ... codesg ends` 定义了一个名为 `codesg` 的代码段，所以需要在程序开头，用 `assume` 将 CS 寄存器和 `codesg` 段相关联（CS 寄存器用于代码的执行）。



- `codesg` 标号

汇编程序中，除了汇编指令和伪指令外，还有一些标号，比如 "codesg" 。一个标号代指了一个地址。比如 `codesg` 在 `segment` 的前面，作为一个段的名称，这个段名称最终被编译、连接程序处理为一个段的段地址。



- 程序返回

程序在 DOS 系统（单任务系统）下的运行方式：运行一个程序时，会将 CPU 的控制器交给程序，直到程序结束，将 CPU 控制权交还给 DOS 系统。

我们会把上述的过程称之为：程序返回。但如果程序没有被结束，则 CPU 会被程序一直占用，没办法干别的事，且会一直执行命令，然后产生错误，这并不是我们所期望的。

所以我们需要使用指令来进行程序返回，其指令为：

```assembly
mov ax,4c00h
int 21h
```

---

### 编辑、编译、连接、执行

#### 0x01 编辑

我们可以使用任意文本编辑器编辑源程序，只要最终将其存储为纯文本文件即可。下面会使用 DOS 下的 Edit，进行编辑：

1. 进入 DOS 系统，运行 Edit 编辑器：

   ```
   c:\edit
   ```

   

2. 在 Edit 中编辑程序，输入以下指令：

   ```assembly
   assume cs:demo
   
   demo segment
   
   	mov ax,0123h
   	mov bx,0456h
   	add ax,bx
   	add ax,ax
   	
   demo ends
   
   end
   ```

   

3. `Alt+F` 选择 `Save` ，输入保存的名称 `1.asm`，按 `Enter` 键确定，结束编辑。



#### 0x02 编译

我们已经通过 0x01 节中得到了一个源程序文件 `demo.asm` ，接下来我们需要对它进行编译，这里选择的编译器是微软的 masm5.0 汇编编译器：

1. 进入 DOS 系统，运行 masm 编译器

   - 运行后，会输出一些版本信息，然后提示输入将要别编译的源程序文件名

   ![masm编译器初始信息](C:\Users\88561\Desktop\Pwn\MarkDown\images\day004_0x02_1.png)

   

2. 输入要编译的源程序文件名，按 `Enter` 键

   - 如果源程序的文件名不是以 `asm` 为扩展名的话，就需要输入文件全名，如果是`asm` 为扩展名，则可以省略扩展名

   ![键入源程序文件名](C:\Users\88561\Desktop\Pwn\MarkDown\images\day004_0x02_2.png)

   

3. 输入目标文件的名称

   - 这一步是我们对源程序编译后得到的文件的命名，它默认会以 `<源程序文件名>.obj` 的名称进行生成
   - 这步可以指定目标文件的生成目录，例如 `c:\windows\Users\*\Desktop\1`
   - 如果没有特殊的命名要求，可以省略不写

   ![键入目标文件的名称](C:\Users\88561\Desktop\Pwn\MarkDown\images\day004_0x02_3.png)

   

4. 输入列表文件的名称

   - 这个文件是编译器将源程序编译为目标文件的过程中产生的中间结果
   - 这个文件并不是必要的，所以省略不填，跳过即可

   ![键入列表文件的名称](C:\Users\88561\Desktop\Pwn\MarkDown\images\day004_0x02_4.png)

   

5. 输入交叉引用文件的名称

   - 这个文件是编译器将源程序编译为目标文件的过程中产生的中间结果

   - 这个文件并不是必要的，所以省略不填，跳过即可

   ![键入交叉引用文件的名称](C:\Users\88561\Desktop\Pwn\MarkDown\images\day004_0x02_5.png)

6. 编译完成

   - 编译完成后，编译器最后会输出两行信息告诉我们源程序中是否有错误

   

#### 0x03 连接

我们已经通过 0x02 节中得到了一个编译后的目标文件 `demo.obj` ，接下来我们需要对它进行链接，这节需要用到的是微软的 Overlay Link3.60 连接器：



1. 进入 DOS 系统，运行 link 连接器

   - 显示基本同上，显示程序简介，然后需要键入要被连接的目标文件名称

   ![link连接器初始信息](C:\Users\88561\Desktop\Pwn\MarkDown\images\day004_0x03_1.png)

   

2. 输入要被连接的目标文件名称，按 `Enter` 键

   - 也是可以简写，省略后缀，条件同上

   ![键入目标文件名](C:\Users\88561\Desktop\Pwn\MarkDown\images\day004_0x03_2.png)

   

3. 输入可执行文件的名称

   - 这一步是我们对可执行文件的命名，它的默认命名同上
   - 这里也可以指定可执行文件的生成目录
   - 如果没有特殊的命名要求，可以省略不写

   ![键入可执行文件的名称](C:\Users\88561\Desktop\Pwn\MarkDown\images\day004_0x03_3.png)

   

4. 往下两步就是生成映像文件和输入库文件的名称

   - 映像文件是可执行文件生成过程中产生的中间结果
   - 输入库文件是该程序需要包含一些可调动的子程序时，将库和该程序连接在一起
   - 两者都可以忽略

   ![]()

   

5. a

#### 0x04 编译和连接的简化

#### 0x05 执行





