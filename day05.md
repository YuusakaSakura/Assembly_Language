### 0x01 [BX]

前面我们学习了访问内存单元的指令 [0]，现在还有一种新的方法，就是将偏移地址存入 BX 寄存器中，然后套上 [] ，即 [bx]，例如：

```assembly
mov bx,10h
mov ax,[bx]		; 同等于 ds:[10h]
```

注意：只能将偏移位存入 BX 寄存器，其他通用寄存器会发生错误


---



### 0x02 loop

我们可以使用 loop 指令来实现指令的循环，减少指令的重复率，增加源文件整洁感。loop 指令的格式是：`loop <Tag>`， CPU 在执行 loop 指令时，会有两步操作：

1. 执行 cx = cx - 1
2. 判断 cx 中的值，如果不为 0 则返回标号处执行指令，如果为 0 则往下执行指令

可以看出 cx 中的值影响着 loop 指令的执行结果，下面会通过一个程序来详细的讲解 loop 指令的具体应用：

```assembly
/* 例如，我们现在需要计算 2^10，然后将结果存在 AX 中： */
assume cs:code
code segment

	mov ax,2
	
	mov cx,9	; 因为 ax = 2^1 所以只需要循环 9 次
s:  add ax,ax	; 这里是 Tag S ，一个地址，存放着一条指令
	loop s		; 只要 cx != 0 Tag S 的指令都会被执行一次
				; 最后得到 ax = 400h = 1024
	mov ax,4c00h
	int 21h
	
code ends
end
```

从上面可以得出，用 cs 和 loop 指令相配合实现循环功能的三个要点：

1. 在 cx 中存放着循环次数
2. loop 指令中的 Tag 需要放置在前面
3. 要循环执行的指令，要在 Tag 和 loop 指令中间

```assembly
	mov cx,/* 需要循环的次数 */
s:
	/* 需要循环的指令 */
	loop s
```

---



### 0x03 一段安全的段空间

1. 我们需要直接向一段内存中写入内容
2. 这段内存空间不应存放系统或者其他程序的代码或数据，否则写入操作可能会引发错误
3. DOS  方式下，一般情况下 0:200 ~ 0:2ff 空间中没有系统或其他程序的数据或代码
4. 以后，如果需要直接向一段内存中写入内容时，就使用 0:200 ~ 0:2ff 这段空间

---



### 0x04 段前缀

我们可以在访问内存单元的指令中显式的给出内存单元的段地址所在的段寄存器，例如：

```assembly
mov ax,ds:[bx]
mov ax,ds:[0]

mov ax,es:[bx]
mov ax,es:[0]
```

这些会出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的 "ds:" "cs:" "ss:" "es:"，在汇编语言中称为段前缀。

---

